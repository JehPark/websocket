## 🏗️ Step 1: Blocking I/O & Echo Server

가장 기본적인 소켓 통신의 흐름을 이해하는 단계입니다.

* **Socket API 이해:** `bind`, `listen`, `accept`, `read`, `write`의 시스템 콜 흐름을 익혀야 합니다.
* **Rust의 `std::net`:** `TcpListener`와 `TcpStream` 사용법을 숙지하세요.
* **동기식 처리의 한계:** 한 클라이언트가 연결되어 `read`에서 대기(Blocking) 중일 때, 왜 다른 클라이언트가 접속하지 못하는지 그 **논리적 병목**을 파악하는 것이 중요합니다.
* *부족할 수 있는 부분:* 이때 "스레드를 무한정 늘리면 되지 않나?"라는 생각이 들 수 있습니다. 하지만 스레드 생성 비용과 **Context Switching** 오버헤드에 대해 미리 고민해 보세요.



## 🚀 Step 2: `epoll` & Non-blocking I/O

단일 스레드로 수만 개의 연결(C10K 문제)을 처리하는 핵심 마법입니다.

* **File Descriptor (FD):** 리눅스에서 모든 것은 파일이며, 소켓 또한 FD로 관리된다는 점을 이해해야 합니다.
* **Edge Triggered (ET) vs Level Triggered (LT):** `epoll`의 두 가지 동작 방식 차이를 명확히 알아야 데이터 유실을 막을 수 있습니다.
* **Event Loop:** 무한 루프 내에서 `epoll_wait`를 호출하고, 이벤트가 발생한 FD만 골라 처리하는 구조를 설계해야 합니다.
* **Rust 저수준 바인딩:** Rust 표준 라이브러리는 `epoll`을 직접 노출하지 않습니다. `libc` 크레이트를 사용해 직접 시스템 콜을 호출하거나, 입문용으로 `mio` 크레이트의 소스코드를 분석해 보는 것을 추천합니다.

## 🧵 Step 3: Thread Pool & Worker-Acceptor Pattern

I/O는 빠르지만, 비즈니스 로직(계산)이 무거워지면 전체 서버가 느려집니다.

* **관심사 분리:** 네트워크 이벤트를 받는 'Acceptor/Reactor' 스레드와 실제 연산을 수행하는 'Worker' 스레드 풀을 분리하는 아키텍처를 설계하세요.
* **MPSC (Multi-Producer, Single-Consumer) Queue:** 스레드 간에 작업(Task)을 안전하게 전달하기 위한 채널(Channel) 개념이 필요합니다.
* **Send & Sync Trait:** Rust에서 스레드 간 데이터를 안전하게 넘기기 위해 반드시 이해해야 하는 핵심 개념입니다. 이 벽을 넘지 못하면 컴파일 에러의 늪에 빠질 수 있습니다.

## 📨 Step 4: Protocol & Serialization

데이터를 어떻게 규격화해서 보낼 것인가의 문제입니다.

* **Framing:** TCP는 스트림 지향 프로토콜이라 데이터의 경계가 없습니다. "어디서부터 어디까지가 한 패킷인가?"를 정의하는 방법(Length-prefixing 등)을 배우세요.
* **Endianness:** 네트워크 바이트 순서(Big-Endian)와 호스트 바이트 순서에 대한 이해가 필요합니다.
* **Zero-copy Deserialization:** 성능 극대화를 위해 메모리 복사를 최소화하는 `rkyv`나 `serde`와 같은 라이브러리의 최적화 기법을 살펴보세요.

# EchoServer

지금까지 나누었던 대화와 제공된 소스 자료들을 바탕으로, 유닉스/리눅스 네트워크 프로그래밍의 핵심 개념들을 5가지 주요 주제로 나누어 요약해 드리겠습니다.

### 1. TCP 소켓 API의 역할과 연결 흐름 (Chapter 4)

고수준 언어(Rust 등)의 네트워크 라이브러리 뒤에는 C 언어 기반의 OS 커널 API가 숨어 있으며, 그 동작 흐름은 다음과 같습니다.

- **`socket` & `bind`:** 통신을 위한 엔드포인트를 만들고, 서버의 경우 자신의 로컬 IP와 포트를 지정합니다. 이때 원격지 주소는 지정되지 않은 와일드카드 상태입니다.
- **`listen`:** 소켓을 클라이언트의 접속을 기다리는 '수동 소켓'으로 변환하고, 커널 백그라운드에 두 개의 큐(미완료 연결 큐, 완료된 연결 큐)를 만들어 3방향 핸드셰이크가 끝난 연결들을 차곡차곡 쌓아둡니다.
- **`accept`:** 완료된 연결 큐에서 연결을 하나 꺼내오며, **해당 클라이언트와 전담하여 통신할 완전히 새로운 '연결된 소켓(Connected socket)'을 생성**하여 반환합니다. 원래의 '리스닝 소켓'은 그대로 남아 다음 연결을 기다립니다.

### 2. 양방향 통신(Full-Duplex)과 데이터 송수신

- TCP는 하나의 연결 위에서 송신과 수신 방향이 완전히 독립적으로 관리되는 양방향 통신을 제공합니다. 커널 내부에는 송신 버퍼와 수신 버퍼가 따로 존재합니다.
- `read` 반환값이 0인 경우는 클라이언트가 연결을 종료(FIN 패킷 전송)했음을 의미하며, 이를 통해 서버는 깔끔하게 통신을 종료할 수 있습니다.
- 일반적인 `close` 대신 `shutdown`을 사용하면 읽기나 쓰기 중 한쪽 방향의 연결만 닫는 **반쪽 닫힘(Half-Close)**이 가능하여, 일괄 처리(Batch mode) 시 파이프라인의 데이터를 안전하게 모두 주고받을 수 있습니다.

### 3. 다중 클라이언트 처리: 동시성(Concurrent) 서버 구조

`accept`로 생성된 새 소켓을 혼자 처리하면 다른 클라이언트들이 무한정 대기하는 병목(Iterative Server)이 발생합니다. 이를 해결하기 위해 동시성 서버를 구축합니다.

- **`fork`를 통한 역할 분담:** `accept` 직후 부모 프로세스는 `fork`를 호출해 자식 프로세스를 복제합니다. 자식은 연결된 소켓으로 통신을 전담하고, 부모는 연결된 소켓을 닫고 다시 `listen` 상태로 돌아갑니다.
- **파일 디스크립터의 참조 횟수(Reference count):** 부모가 연결된 소켓을 닫아도 연결이 끊기지 않는 이유는 `fork` 시 커널의 `file` 구조체 참조 횟수가 2로 증가하기 때문입니다.
- **`exec`의 활용:** 만약 연결 처리와 실제 데이터 처리를 다른 프로그램이 해야 한다면(예: `inetd` 슈퍼서버), `fork` 이후 `exec`을 호출해 프로세스 껍데기를 교체합니다. 이때 소켓 디스크립터는 유지되므로 새로운 프로그램이 통신을 이어받을 수 있습니다.

### 4. 고성능 서버 설계 대안과 Thundering Herd (Chapter 30)

대규모 트래픽 환경에서는 매번 `fork`를 호출하는 오버헤드를 줄여야 합니다.

- **사전 포크 / 사전 스레딩 (Prefork / Prethread):** 서버 시작 시 미리 자식 프로세스나 스레드의 풀(Pool)을 만들어두는 방식입니다.
- **천둥소리를 내는 소떼 (Thundering Herd) 문제:** 여러 자식 프로세스가 동일한 리스닝 소켓을 공유하며 동시에 `accept`를 호출해 대기하다가, 단 1명의 클라이언트가 접속해도 커널이 대기 중인 모든 자식을 깨워버려 CPU 자원이 낭비되는 현상입니다.
- 이를 해결하기 위해 실제 고성능 서버들은 **파일 잠금(File locking)이나 스레드 뮤텍스(Mutex)**를 사용해 한 번에 하나의 프로세스만 `accept`를 호출하도록 제어합니다.

### 5. 견고한 서버를 위한 예외 처리 (Chapter 5)

네트워크 프로그래밍은 정상적인 흐름보다 예외 상황 처리가 더 중요합니다.

- **좀비 프로세스 방지:** 자식 프로세스가 종료될 때 발생하는 `SIGCHLD` 시그널을 부모가 반드시 처리해야 합니다. 여러 신호가 겹칠 수 있으므로 `wait` 대신 **`waitpid` 함수를 루프 안에서 호출**하여 모든 좀비를 수거해야 합니다.
- **인터럽트된 시스템 콜 (EINTR):** 대기 상태(`accept` 등)에서 시그널 처리가 발생하면 함수가 에러를 반환하며 중단되므로, 코드가 이를 감지하고 자동으로 재시작하게 짜야 합니다.
- **서버/네트워크 충돌 대처:** 통신 중 서버가 강제 종료되면 RST 패킷이 날아오고, 여기에 대고 쓰기를 시도하면 `SIGPIPE` 시그널이 발생하여 프로그램이 죽을 수 있습니다. 이를 막기 위해 시그널을 무시하거나 I/O 다중화(`select`, `poll`)를 사용해 예외를 감지해야 합니다.

### 6. 로컬 IPC 통신: 유닉스 도메인 프로토콜 (Chapter 15)

단일 컴퓨터 내의 프로세스 간 통신을 외부 네트워크를 거치지 않고 처리하여 성능을 극대화하는 방식입니다.

- IP와 포트 대신 **파일 시스템의 경로명(Pathname)**을 주소(`sockaddr_un`)로 사용하며, `bind` 전에 기존 소켓 파일을 지우는 `unlink` 과정이 필수적입니다.
- **특수 기능:** 단순히 데이터를 주고받는 것을 넘어, 서로 다른 프로세스 간에 **열린 파일 디스크립터를 전달**하거나, 커널이 보증하는 **클라이언트의 권한(자격 증명, Credentials)을 수신**하여 안전하게 보안을 검증할 수 있습니다.